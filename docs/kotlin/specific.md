Технический Отчет: Адаптация Объектно-Ориентированных Метрик для Анализа Кода Kotlin

I. Введение: Методологическая База и Фундаментальные Отличия Kotlin

1.1. Контекст, Цель и Методология Обеспечения Метрической Непрерывности

Переход от Java к Kotlin в рамках одного проекта анализа требует тщательной калибровки традиционных объектно-ориентированных метрик. Kotlin, будучи прагматичным языком, нацелен на устранение синтаксической избыточности Java, что приводит к значительно более лаконичному коду.[1, 2] Код на Kotlin компилируется в байткод JVM и на 100% интероперабелен с Java.[3] Однако, синтаксический "сахар" и идиомы Kotlin (такие как свойства, классы данных и функции верхнего уровня) скрывают за собой сложную структуру JVM-сущностей (поля, геттеры, сеттеры), которые являются основой для расчета большинства классических метрик, таких как CK (Chidamber-Kemerer) и MOOD (Metrics for Object-Oriented Design).

Целью данного отчета является определение логических различий и необходимых модификаций в расчете метрик для кода на Kotlin, чтобы обеспечить _семантическую эквивалентность_ измерений. Это означает, что метрический инструмент должен распознавать краткие конструкции Kotlin и разлагать их на полный набор сгенерированных ОО-сущностей, чтобы избежать ложного занижения сложности или завышения качества.

1.2. Фундаментальное Влияние Ключевых Концепций Kotlin на ООП Структуры

Ключевые концепции Kotlin, требующие адаптации логики подсчета метрик, сосредоточены на трех основных векторах:

1.2.1. Конвергенция Атрибутов и Методов (Properties)

В Kotlin _свойство_ (`Property`) — это единое объявление, которое абстрагирует поле (Backing Field) и его методы доступа (Getter и, опционально, Setter).[4, 5] Для Java-ориентированного анализа, где методы и поля считаются отдельно, это создает проблему. Для точного расчета метрик WMC, LCOM, AHF, и MHF, объявление одного свойства должно быть разложено на:

1. **Один атрибут (Backing Field):** для метрик, связанных с состоянием (например, NOA, AHF, LCOM).

2. **Один или два метода (Accessors):** Getter для `val` (read-only) и Getter/Setter для `var` (mutable).[4, 6] Эти аксессоры должны учитываться как методы при расчете WMC (Weighted Methods per Class), NOM (Number of Methods), и MHF (Method Hiding Factor).

1.2.2. Новая Модульность и Инкапсуляция (`internal` и Top-Level Declarations)

Kotlin вводит модификатор видимости `internal`, который ограничивает доступ к членам класса или функциям в пределах одного _модуля_.[7] Это создает новый уровень инкапсуляции, отличный от традиционных `public`, `protected`, и `private`.[7, 8] Влияние `internal` критически важно для метрик инкапсуляции (MHF, AHF) и метрик сопряжения между пакетами (Robert C. Martin metrics).

Кроме того, Kotlin позволяет объявлять функции и свойства на верхнем уровне файла (Top-Level Declarations), без явного помещения их в класс.[9] В скомпилированном байткоде эти элементы помещаются в статические утилитарные классы (Synthetic Classes). Для целей метрик пакета и проекта, эти синтетические классы должны быть учтены при подсчете статических сущностей.

1.2.3. Влияние Краткости на Сложность (Data Classes и Expression Bodies)

Конструкции, такие как `data class`, значительно сокращают LOC и NCSS, но несут скрытую сложность, поскольку компилятор автоматически генерирует стандартные методы (`equals()`, `hashCode()`, `toString()`, `copy()`, и `componentN()`).[10] Эти неявные методы должны быть включены в расчет WMC, NOM и RFC, поскольку они увеличивают размер интерфейса класса и его потенциальную сложность.

II. Базовые Метрики Размера и Структуры (Project & Package Levels)

2.1. Метрики Размера Кода (Lines Of Code, Non-Commenting Source Statements)

Lines Of Code (LOC)

Подсчет LOC (Lines Of Code) остается в целом идентичным для Kotlin и Java, поскольку он представляет собой физический размер файла.

Non-Commenting Source Statements (NCSS)

NCSS в Kotlin, как правило, ниже по сравнению с функционально эквивалентным кодом на Java, что часто интерпретируется как повышение поддерживаемости.[2] Однако краткость Kotlin требует адаптации логики подсчета NCSS:

1. **Primary Constructors:** Объявление свойств в первичном конструкторе, например, `class User(val name: String, val age: Int)`, должно считаться как одно NCSS, несмотря на то, что оно эквивалентно объявлению поля и генерации аксессоров.

2. **Expression-Body Functions:** Функции, тело которых записано в одну строку, должны считаться как 1 NCSS, если они содержат логику.

3. **Implicit NCSS:** Наиболее важной корректировкой является то, что низкий NCSS, обусловленный использованием `data class` или expression bodies, маскирует сложность, которую эти конструкции несут. Например, класс данных, объявленный в одной строке, имеет NCSS = 1, но функционально он эквивалентен классу с 5–6 явно реализованными методами.[10] Для обеспечения точного Maintainability Index (MI), который включает NCSS, необходимо компенсировать эту скрытую сложность за счет точного подсчета CC (Cyclomatic Complexity) и Halstead Volume.

2.2. Метрики Контейнеров (Classes, Interfaces, Static Classes)

Number Of Concrete/Abstract Classes, Number Of Interfaces

Идентификация базовых типов контейнеров остается схожей: используются ключевые слова `class`, `abstract class`, и `interface`.[11]

1. **Data Classes:** `data class` всегда считается конкретным классом, поскольку они не могут быть `abstract` или `open`.[10]

2. **Sealed Classes/Interfaces:** `sealed class` и `sealed interface` должны быть классифицированы как абстрактные типы, поскольку они не могут быть непосредственно инстанцированы.[11]

3. **Interfaces с Реализациями:** Kotlin Interfaces могут содержать реализации по умолчанию для методов и аксессоров свойств.[12] Это не меняет их классификации как интерфейсов, но влияет на метрики наследования (MIF).

Number Of Static Classes (NSC)

В Java NSC часто соответствует классам, содержащим только статические члены. В Kotlin концепция `static` заменена. Логика подсчета NSC должна быть расширена для включения:

1. **Явные Object Declarations:** `object` (Singleton) является синглтоном, реализованным как статический класс с одним экземпляром. Он должен быть учтен как конкретный класс, выполняющий роль статического контейнера.

2. **Companion Objects:** `companion object` используется для размещения функций, которые семантически близки к статическим методам класса.[13] Сам класс-контейнер, в котором объявлен `companion object`, остается конкретным или абстрактным классом, но `companion object` может быть рассмотрен как источник статических членов.

3. **Synthetic Classes для Top-Level Declarations (TLD):** Функции и свойства, объявленные на верхнем уровне файла, компилируются в статические методы/поля синтетического класса с именем файла (`FileNameKt`). Поскольку эти TLD нарушают традиционную ОО-инкапсуляцию, содержащий их синтетический класс должен быть учтен в NSC. Если этот контейнер будет проигнорирован, метрики проекта будут давать ложное представление о чистой ОО-системе.

III. Метрики Инкапсуляции и Наследования (MOOD, CK Structural)

3.1. Факторы Инкапсуляции (MHF: Method Hiding Factor, AHF: Attribute Hiding Factor)

Метрики MOOD критически зависят от модификаторов видимости (`private`, `protected`, `internal`, `public`).[7, 8]

Attribute Hiding Factor (AHF)

AHF измеряет долю скрытых атрибутов в системе.[14] Атрибутами, в контексте Kotlin, являются Backing Fields свойств.

1. **Скрытность Backing Fields:** Backing Field (поле, которое хранит значение свойства) в Kotlin всегда является невидимым и приватным (инкапсулированным) извне класса. Таким образом, если AHF рассчитывается на основе сокрытия полей состояния, этот фактор будет стремиться к 100%.

2. **Учет** **internal****:** Если свойство объявлено как `internal`, его аксессоры видимы в пределах модуля, но само поле остается скрытым.

Method Hiding Factor (MHF)

MHF измеряет долю скрытых методов.[15]

1. **Включение Аксессоров:** MHF должен включать в подсчет **все сгенерированные геттеры и сеттеры** свойств, в дополнение к явно объявленным функциям.

2. **Видимость Аксессоров:** Видимость аксессоров определяется модификатором свойства. Если свойство `public`, геттер и сеттер (если он есть) также `public` (если не используется приватный сеттер, `private set`).[7]

3. **Обработка** **internal****:** Модификатор `internal` вводит ограничение видимости на уровне модуля.[7] Для расчета MV (количество других классов, где метод видим) в формуле MHF, общее количество классов (C) должно быть заменено на количество классов в текущем модуле (Cmodule​) для членов, помеченных как `internal`. Если `internal` не будет учтен, и MV будет сравниваться с Ctotal​, вклад `internal` в инкапсуляцию на уровне модуля будет недооценен.

3.2. Факторы Наследования (DIT, NOC, MIF, AIF)

DIT (Depth of Inheritance Tree) и NOC (Number of Children)

Ключевое отличие Kotlin от Java заключается в том, что классы и методы по умолчанию являются `final`.[11, 16]

1. **Ограничение Наследования:** Плагин должен учитывать в DIT и NOC только те классы, которые явно помечены как `open` или `abstract`, поскольку только они могут быть унаследованы.[16] Классы, не имеющие модификатора, не могут иметь потомков (NOC=0).

2. **Семантика Дизайна:** Низкие значения DIT и NOC в Kotlin не обязательно свидетельствуют о недостатках ОО-дизайна, а скорее соответствуют идиоме языка, направленной на предотвращение проблемы "хрупкого базового класса" (Fragile Base Class Problem).[16, 17]

MIF (Method Inheritance Factor) и AIF (Attribute Inheritance Factor)

MIF (унаследованные методы) и AIF (унаследованные атрибуты) рассчитываются на основе количества унаследованных, но не переопределенных членов.

1. **Наследование Аксессоров и Свойств:** Унаследованные свойства должны вносить вклад в AIF (как унаследованные Backing Fields) и в MIF (как унаследованные аксессоры).

2. **Интерфейсы с Реализацией:** Методы (и аксессоры свойств), унаследованные из Kotlin-интерфейсов, которые предоставляют реализации по умолчанию, должны быть учтены в MIF.[12]

IV. Метрики Классового Уровня (CK, Lorenz, Cohesion)

4.1. Взвешенные Методы на Класс (WMC) и Количество Операций (NOM, NOO)

Метрики WMC (Weighted Methods per Class), NOM (Number of Methods) и NOO (Number of Operations) в Kotlin требуют наиболее серьезной модификации логики подсчета.

1. **WMC/NOM/NOO:** Эти метрики должны включать четыре категории сущностей в набор методов (M):

◦ Явно объявленные функции.

◦ Явно объявленные конструкторы (первичные и вторичные).

◦ Аксессоры (геттеры и, если есть, сеттеры) для всех свойств (`val`/`var`).[4, 6]

◦ Все неявные (сгенерированные) методы для `data class` (`equals`, `hashCode`, `toString`, `copy`, `componentN`).[10]

2. **Взвешивание (WMC):** Если WMC рассчитывается как взвешенная сумма сложности (например, по CC) [18]:

◦ Аксессоры со стандартной реализацией (тривиальные геттеры/сеттеры) должны иметь CC, равный 1.

◦ Аксессоры с пользовательскими реализациями (`custom getter`/`custom setter`) должны иметь CC, рассчитанный на основе их внутреннего тела.[4]

4.2. Метрики Связанности (LCOM, TCC, WOC)

Метрики когезии (LCOM, TCC, WOC) измеряют, насколько методы класса используют общие атрибуты.[19, 20]

1. **Критическое Расширение Наборов** M **и** A**:**

◦ Множество методов M должно быть расширено для включения всех аксессоров и сгенерированных методов `data class` (как описано для WMC).

◦ Множество атрибутов A должно включать все Backing Fields.

2. **Искажение Когезии Data Classes:** `data class` гарантирует очень высокий уровень когезии (низкий LCOM, высокий TCC), поскольку все сгенерированные методы (`componentN()`, `copy()`) тривиально обращаются к одному или нескольким полям.[10] Это может искусственно завысить оценку когезии класса. Для более точного анализа архитектурной когезии рекомендуется ввести опцию, исключающую тривиальные пары (Аксессор ↔ Backing Field) из анализа связей, чтобы сосредоточиться на связях между _пользовательскими_ методами.

4.3. Метрики Сопряжения и Абстракции Данных (CBO, RFC, ATFD)

CBO (Coupling Between Object Classes) и RFC (Response for a Class)

CBO и RFC измеряют количество классов, с которыми взаимодействует данный класс.[21]

1. **Extension Functions (EF):** EF — это статические утилитарные функции, которые вызываются в Kotlin так, будто они являются членами класса-ресивера.[22] При вызове EF A.ext() из класса C, класс C зависит как от класса A (ресивера), так и от синтетического контейнерного класса, в котором объявлен EF. Для точного отражения сопряжения:

◦ **CBO:** CBO для C должен быть увеличен за счет зависимости от класса A.

◦ **RFC:** RFC для C увеличивается за счет вызова A.ext().

◦ Необходимо учитывать, что хотя EF улучшают читаемость [23], они создают скрытую зависимость от внешнего модуля. Игнорирование этого сопряжения приведет к ложному занижению CBO.

2. **Top-Level Declarations:** Вызовы TLD из другого пакета должны увеличивать CBO, так как они создают зависимость от синтетического класса-контейнера TLD в целевом пакете.

ATFD (Access To Foreign Data) и NOPA (Number Of Public Attributes)

1. **NOPA:** В Java NOPA считает публичные поля. В Kotlin публичные свойства являются основным механизмом доступа к данным. NOPA должен считаться как количество публичных свойств, поскольку они предоставляют публичный интерфейс доступа к состоянию класса.

2. **ATFD:** Доступ к публичному свойству X.P класса X из класса Y должен быть учтен как доступ к внешним данным (Foreign Data), независимо от того, является ли P полем или использует сгенерированный геттер.

V. Метрики Связанности и Абстракции Пакета (Robert C. Martin)

Метрики Роберта К. Мартина (Ce, Ca, I, A, D) оценивают взаимосвязь между пакетами (или модулями).[24, 25]

5.1. Учет Зависимостей Пакета (Ce: Efferent Coupling, Ca: Afferent Coupling)

Единица Анализа: Пакет vs. Модуль

Традиционно метрики Martin's применяются к пакетам. Однако в Kotlin модификатор `internal` ограничивает видимость до границ _модуля_.[7] В крупномасштабных системах, состоящих из нескольких модулей, граница модуля становится более важной для стабильности, чем граница пакета.[25, 26] Таким образом, для многомодульных проектов единицей стабильности должно быть сочетание пакета и модуля.

Efferent Coupling (Ce)

Ce (исходящее сопряжение) — количество классов в других пакетах, от которых зависит анализируемый пакет.[21, 24]

1. **Учет новых зависимостей:** Ce должен учитывать зависимости, возникающие от использования Top-Level Declarations и Extension Functions, объявленных в других пакетах, так как они создают зависимость от синтетических контейнерных классов этих внешних пакетов.

Afferent Coupling (Ca)

Ca (входящее сопряжение) — количество классов в других пакетах, которые зависят от анализируемого пакета.[24]

1. **Критическая Коррекция** **internal****:** Модификатор `internal` позволяет разработчику контролировать Ca модуля. Если класс A содержит члены, помеченные как `internal`, эти члены не могут быть использованы классами, находящимися за пределами модуля A.

2. **Логика Ca:** При подсчете Ca входящие зависимости от классов в _других_ модулях должны учитываться, только если они обращаются к `public` или `protected` членам. Зависимости, нацеленные исключительно на `internal` члены, должны быть учтены только в пределах текущего модуля. Это гарантирует, что `internal` члены не влияют на внешнюю стабильность модуля, тем самым точно отражая, как Kotlin помогает минимизировать доступность API.[26]

5.2. Абстрактность (A), Нестабильность (I) и Расстояние (D)

Abstractness (A)

Абстрактность рассчитывается как доля абстрактных классов и интерфейсов в пакете A=(Ac​+Ic​)/Nc​.[25] В Kotlin интерфейсы с реализациями по умолчанию по-прежнему считаются интерфейсами и включаются в Ic​.[11, 12]

Instability (I) и Normalized Distance (D)

I=Ce/(Ce+Ca). Эти метрики рассчитываются по стандартным формулам на основе скорректированных значений Ce и Ca.

VI. Метрики Сложности и Объема (Halstead, CC, Cognitive Complexity, Method Level)

Метрики сложности требуют самого глубокого анализа семантики синтаксиса Kotlin, поскольку они лежат в основе оценки `Maintainability Index` (MI).

6.1. Метрики Халстеда (Volume, Difficulty, Effort, Errors)

Метрики Халстеда основаны на токенизации кода на операторы (n1) и операнды (n2).[27, 28, 29] Для Kotlin требуется радикальное расширение словаря операторов.

Расширенный Список Операторов Kotlin (n1):

1. **Операторы Null Safety:**

◦ **?:** (Elvis Operator): Представляет собой условный переход.[30]

◦ **?.** (Safe Call Operator): Используется для безопасного доступа.

◦ **!!** (Not-Null Assertion Operator): Принудительное извлечение значения.

2. **Структурные и Потоковые Операторы:**

◦ Ключевые слова, управляющие потоком: `val`, `var`, `fun`, `when`, `is`, `as`, `in`.

◦ Стрелка лямбда-выражения **->**: Используется для отделения параметров от тела лямбды или для ветвей `when`.[31, 32]

3. **Инфиксные Функции:** При использовании инфиксной нотации (например, `1 shl 2`), сам символ инфиксного вызова должен быть учтен как оператор.

4. **Аксессоры и Конструкторы:** Вызовы сгенерированных геттеров/сеттеров и конструкторов должны учитываться как операторы/операнды в зависимости от контекста.

6.2. Цикломатическая Сложность (CC: McCabe Cyclomatic Complexity)

Цикломатическая Сложность (MCC) измеряет количество линейно независимых путей в методе.[33] Базовый подсчет (CC=1) увеличивается на единицу за каждую точку ветвления потока управления.

1. **when** **Expression:** Конструкция `when` (эквивалентная `switch` в Java) увеличивает сложность. MCC должен увеличиваться на +1 за базовую конструкцию `when`, и дополнительно на +1 за каждое условие (ветвь) внутри тела `when`.[33, 34]

2. **Elvis Operator** **?:****:** Оператор `?:` (Elvis) представляет собой аббревиатурное условное ветвление (`if not null then... else...`) и должен увеличивать CC на +1, так как вводит дополнительный путь выполнения.[30, 33]

3. **Scope Functions:** Функции области видимости (`let`, `run`, `with`, `apply`, `also`) могут увеличивать CC, если они используются для управления потоком (например, для обработки исключений `try-catch` или для нелокального `return`).[33]

6.3. Когнитивная Сложность (Cognitive Complexity)

Когнитивная Сложность (CCx) измеряет сложность понимания кода программистом, наказывая за прерывание линейного потока и вложенность.[35] CCx особенно важна в Kotlin, поскольку синтаксическая краткость может маскировать семантическую сложность.

1. **Elvis Operator** **?:** **и** **when****:** Как и в случае с MCC, они увеличивают CCx (+1 за прерывание потока).

2. **Safe Call Operator** **?.****:** Этот оператор предназначен для повышения безопасности и читаемости, предотвращая необходимость в явной проверке на null.[36, 37] Таким образом, использование `?.` должно увеличивать CCx на +0, поскольку оно упрощает код и соответствует ментальной модели, не вводя явного условного ветвления.[35]

3. **Scope Functions:** Использование Scope Functions (`let`, `run`, `with`, `apply`, `also`) [38] создает новый уровень вложенности, который требует от разработчика сохранения дополнительного контекста (например, переключение между `this` и `it`).[39] Каждая такая функция, создающая новый уровень вложенности, должна увеличивать счетчик CCx, так как это нарушает линейный поток чтения.[33]

6.4. Метрики Методового Уровня

Nesting Depth Metrics

Метрики глубины вложенности (Maximum Nesting Depth, Loop Nesting Depth, Condition Nesting Depth) должны учитывать вложенность, вызванную лямбдами и Scope Functions, поскольку они представляют новый уровень контекста выполнения.[40, 41]

LAA, FDP, NOAV

Метрики доступа к данным (LAA, FDP, NOAV) должны интерпретировать доступ к Kotlin Properties как доступ к атрибуту/переменной, независимо от того, что в байткоде это реализуется через вызов геттера. Доступ X.P к свойству P в другом классе X должен увеличивать FDP (Foreign Data Providers).

6.5. Maintainability Index (MI)

Maintainability Index (MI) рассчитывается на основе Halstead Volume (V) и Cyclomatic Complexity (CC).

MI=171−5.2×ln(V)−0.23×CC−16.2×ln(LOC)

После точной калибровки V (на основе расширенного словаря операторов) и CC (с учетом `when` и `?:`), MI для Kotlin-кода может оказаться выше, чем для Java, из-за более низкого LOC. При этом точность расчета CC и V критически важна, чтобы гарантировать, что этот высокий MI не является ложным следствием игнорирования скрытой сложности.[2]

VII. QMOOD Quality Attributes и Имплементационные Рекомендации

7.1. Влияние на Атрибуты Качества QMOOD

Внедрение Kotlin-специфической логики расчета метрик позволяет более точно оценить влияние языка на атрибуты качества QMOOD:

• **Understandability (Понятность):** Снижение NCSS способствует улучшению понятности. Однако высокая плотность кода, глубокая вложенность Scope Functions и сложных `when` выражений могут увеличить Cognitive Complexity, что отрицательно сказывается на понятности. Для оценки понятности кодла на Kotlin предпочтительным индикатором является Cognitive Complexity, а не только MCC.

• **Flexibility (Гибкость) и Extendibility (Расширяемость):** Использование Extension Functions повышает гибкость (позволяя добавлять функциональность к закрытым классам [22]). С другой стороны, по умолчанию `final` классы и методы [16] снижают традиционную расширяемость через наследование, что является преднамеренным дизайнерским выбором в Kotlin для повышения стабильности.

• **Effectiveness (Эффективность):** Нулевая безопасность (Null Safety) Kotlin предотвращает NullPointerExceptions [36], повышая надежность и, следовательно, эффективность кода, что должно быть отражено через положительную корреляцию с метриками низкой сложности и высокого MI.

7.2. Сводная Таблица: Семантические Корректировки и Изменения в Логике

Для успешной реализации расчета метрик для Kotlin, требуется семантическое разложение синтаксических конструкций на ОО-сущности, как показано ниже.

Таблица 1: Семантическое Преобразование Java vs. Kotlin Конструкций для Расчета Метрик

|   |   |   |   |
|---|---|---|---|
|**Kotlin Construct**|**Entity Type(s) in Metric Calculation**|**Impacted Metrics**|**Логическая Коррекция (Change in Logic)**|
|Property `val`/`var`|Attribute (Backing Field) + Accessors (Method)|WMC, NOM, NOA, AHF, MHF, LCOM, TCC|Разложение свойства на поле и 1-2 метода доступа.|
|`data class`|Class + 5 Implicit Methods|WMC, NOM, RFC, LCOM|Включение сгенерированных методов в набор M.|
|Top-Level Function/Property|Static Class/Method|NSC, Ce, Ca|Создание синтетического класса-контейнера для TLD.|
|`internal` member|Module-Scope visibility|MHF, AHF, Ca|Ограничение расчета видимости (MV) пределами модуля.|
|Extension Function (EF)|Coupling Mechanism|CBO, RFC, Ce|Учет зависимости от класса-ресивера И синтетического класса EF.|
|`when` / `?:`|Conditional Flow|CC, Cognitive Complexity, n1|Увеличение счетчиков CC и CCx, добавление в словарь операторов.|
|Safe Call `?.`|Safety mechanism|Cognitive Complexity|Увеличение CCx на +0 (нейтрально).|
