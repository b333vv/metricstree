# Refactoring Plan: Kotlin Metric Visitors Alignment

## 1. Executive Summary & Goals
The objective of this plan is to refactor the existing Kotlin metric visitors in `org.b333vv.metric.model.visitor.kotlin` to strictly align with the language-specific metric definitions provided in `doc/kotlin/specific.md`.

**Key Goals:**
1.  **Semantic Accuracy:** Ensure metrics account for Kotlin syntactic sugar (Properties, Data Classes, Extension Functions) as defined in the specification.
2.  **Complexity Precision:** Refine Cyclomatic and Cognitive complexity calculations to handle Kotlin-specific operators (`when`, `?.`, `?:`) correctly.
3.  **Structural Correctness:** Adjust coupling and inheritance metrics to respect Kotlin's default finality and `internal` visibility modifiers.

## 2. Current Situation Analysis
The current Kotlin visitors (`src/main/java/org/b333vv/metric/model/visitor/kotlin/**/*.java`) implement standard object-oriented metrics but largely treat Kotlin structures as direct mappings to Java AST nodes without accounting for the implicit code generation and semantic differences described in `doc/kotlin/specific.md`.

**Key Gaps:**
*   **Properties:** Treated as simple fields, ignoring the implicit getter/setter methods which affects NOM, WMC, and LCOM.
*   **Data Classes:** Implicit methods (`copy`, `componentN`, etc.) are currently ignored in method counts.
*   **Complexity:** Specific Kotlin operators (Elvis `?:`, Safe Call `?.`) are not explicitly handled in complexity visitors.
*   **Visibility:** The `internal` modifier is not distinct from `public` in current visibility checks, affecting encapsulation metrics.

## 3. Proposed Solution / Refactoring Strategy

### 3.1. High-Level Design
The refactoring will focus on modifying the logic within the existing Visitor classes. No new architectural layers are required. The `KotlinModelBuilder` will remain the entry point, delegating to specific visitors. We will introduce helper utilities where necessary to centralize logic for "implicit member expansion" (e.g., calculating the virtual methods generated by a Property).

### 3.2. Key Components / Modules
*   **`org.b333vv.metric.model.visitor.kotlin.type`**: Visitors calculating class-level metrics (NOM, WMC, LCOM, etc.).
*   **`org.b333vv.metric.model.visitor.kotlin.method`**: Visitors calculating method-level metrics (CC, Cognitive Complexity).

### 3.3. Detailed Action Plan / Phases

#### Phase 1: Property and Data Class Expansion (NOM, WMC, RFC)
*Objective: Account for implicit methods generated by Kotlin compiler.*

*   **Task 1.1: Refactor `KotlinNumberOfMethodsVisitor` (NOM)**
    *   **Rationale:** `doc/kotlin/specific.md` states Properties count as Accessors, and Data Classes have implicit methods.
    *   **Action:**
        *   Modify `visitClass`:
            *   Iterate `KtProperty` declarations. For each `var`, add 2 to count (get/set). For each `val`, add 1 (get).
            *   Check `KtClass.isData()`. If true, add count for `equals`, `hashCode`, `toString`, `copy`, and `componentN` (for each constructor parameter).
    *   **Deliverable:** NOM metric reflects implicit methods.

*   **Task 1.2: Refactor `KotlinWeightedMethodCountVisitor` (WMC)**
    *   **Rationale:** Implicit accessors and data class methods have complexity (usually 1).
    *   **Action:**
        *   Add logic to sum complexity of implicit methods (default complexity = 1).
        *   If a Property has a custom accessor with a body, calculate its complexity using `KotlinMcCabeCyclomaticComplexityVisitor` logic.

*   **Task 1.3: Refactor `KotlinResponseForClassVisitor` (RFC)**
    *   **Rationale:** RFC must include calls to implicit methods.
    *   **Action:** Include signatures of implicit methods (getters/setters, data class methods) in the response set.

#### Phase 2: Complexity Refinement (CC, Cognitive Complexity)
*Objective: Handle Kotlin-specific control flow operators.*

*   **Task 2.1: Refactor `KotlinMcCabeCyclomaticComplexityVisitor` (CC)**
    *   **Rationale:** `doc/kotlin/specific.md` defines specific weights for `when` and `?:`.
    *   **Action:**
        *   Implement `visitBinaryExpression`: If operation is `ELVIS` (`?:`), increment complexity.
        *   Implement `visitSafeQualifiedExpression`: If used in a conditional context (heuristic), increment complexity.
        *   Verify `visitWhenExpression`: Ensure it counts every branch + else.

*   **Task 2.2: Refactor `KotlinCognitiveComplexityVisitor` (CCM)**
    *   **Rationale:** `doc/kotlin/specific.md` specifies `?.` (Safe Call) adds +0 complexity.
    *   **Action:**
        *   Explicitly handle `KtSafeQualifiedExpression` to ensure it does *not* increment nesting or complexity.
        *   Ensure `KtBinaryExpression` with `ELVIS` (`?:`) increments complexity.

#### Phase 3: Cohesion and Coupling (LCOM, CBO, ATFD)
*Objective: Correctly map Property access to Backing Fields.*

*   **Task 3.1: Refactor `KotlinLackOfCohesionOfMethodsVisitor` (LCOM)**
    *   **Rationale:** LCOM measures field usage. In Kotlin, `obj.prop` is a getter call, but semantically it accesses the backing field for cohesion purposes.
    *   **Action:**
        *   When visiting `KtSimpleNameExpression` or `KtDotQualifiedExpression`:
            *   If it resolves to a `KtProperty` within the same class:
                *   Treat it as an access to the *Backing Field*.
                *   Treat the *implicit getter/setter* as methods that access this backing field.
        *   Update the graph construction to include these implicit nodes (accessors) and edges (field usage).

*   **Task 3.2: Refactor `KotlinAccessToForeignDataVisitor` (ATFD)**
    *   **Rationale:** Accessing `foreignObj.prop` is accessing foreign data.
    *   **Action:**
        *   Ensure `KtDotQualifiedExpression` resolving to a property of another class counts towards ATFD.

#### Phase 4: Visibility and Inheritance (MHF, AHF, DIT, NOC)
*Objective: Handle `internal` and `open`/`final` defaults.*

*   **Task 4.1: Refactor Visibility Logic (MHF, AHF)**
    *   **Rationale:** `internal` is a distinct visibility level.
    *   **Action:**
        *   In `KotlinNumberOfPublicAttributesVisitor` (and similar), explicitly check for `KtTokens.INTERNAL_KEYWORD`.
        *   Update logic: `internal` should NOT count as `public` for NOPA, but should be handled specifically for MHF/AHF (visible within module, hidden outside). *Note: Since MHF/AHF are often project-wide, ensure the visitor correctly categorizes `internal` members.*

*   **Task 4.2: Refactor `KotlinDepthOfInheritanceTreeVisitor` (DIT) & `KotlinNumberOfChildrenVisitor` (NOC)**
    *   **Rationale:** Kotlin classes are `final` by default.
    *   **Action:**
        *   **NOC:** Ensure that classes without `open` or `abstract` modifiers return 0 immediately (optimization).
        *   **DIT:** Ensure `Any` is treated as the root (depth 0 or 1 depending on convention), similar to `Object` in Java.

### 3.4. Data Model Changes
*   No changes to `ClassElement` or `MethodElement` data structures are required. The changes are purely in how the metrics are computed and populated into these elements.

### 3.5. API Design / Interface Changes
*   No public API changes. The refactoring is internal to the visitor implementations.

## 4. Key Considerations & Risk Mitigation

### 4.1. Technical Risks
*   **Implicit Method Explosion:** Adding implicit methods for every property might bloat the `MethodElement` list if we were to create actual nodes.
    *   *Mitigation:* We will *not* create `MethodElement` nodes for implicit accessors in the UI tree unless explicitly requested. Instead, we will just account for them in the *metric values* (NOM, WMC) calculated by the visitors.
*   **Resolution Limitations:** Some logic (like LCOM property resolution) relies on PSI resolution which might be incomplete in the `LightJavaCodeInsightFixtureTestCase` environment or without full project indexing.
    *   *Mitigation:* Use heuristic fallbacks (name matching) where resolution fails, as seen in existing visitors.

### 4.2. Dependencies
*   **Kotlin PSI:** Depends on `org.jetbrains.kotlin.psi` classes. Ensure the plugin dependency on Kotlin is correctly configured (already present).

### 4.3. Non-Functional Requirements
*   **Performance:** Calculating implicit metrics for data classes involves iterating constructor parameters. This is negligible.
*   **Maintainability:** The logic for "is this a property?" or "is this a data class?" should be extracted to a utility class (`KotlinMetricUtils`) to avoid code duplication across visitors.

## 5. Success Metrics / Validation Criteria
*   **Unit Tests:** Existing tests in `KotlinClassMetricsIntegrationTest` and `KotlinMethodMetricsIntegrationTest` must pass.
*   **Specific Verification:**
    *   A Data Class with 1 property should have NOM >= 1 (ctor) + 1 (getter) + 5 (standard) = 7 (depending on exact standard method count).
    *   A class with `val x` should have NOM = 1 (getter) + 1 (ctor) = 2 (assuming no other methods).
    *   Cyclomatic Complexity of a function with `?:` should be > 1.

## 6. Assumptions
*   The `doc/kotlin/specific.md` is the source of truth.
*   We are calculating metrics based on the *source code* view, but trying to approximate the *bytecode/runtime* complexity/structure where relevant (e.g., implicit accessors).

## 7. Open Questions
*   **LCOM for Data Classes:** Data classes are inherently cohesive (data holders). Should we force LCOM=0 for them, or let the calculation run? *Assumption: Let calculation run, but expect high cohesion (low LCOM).*
*   **Synthetic Classes:** `KotlinModelBuilder` creates synthetic classes for top-level functions. Should file-level properties count towards this synthetic class's NOA? *Assumption: Yes.*