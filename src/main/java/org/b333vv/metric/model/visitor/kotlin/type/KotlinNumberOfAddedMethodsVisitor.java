package org.b333vv.metric.model.visitor.kotlin.type;

import org.b333vv.metric.model.metric.Metric;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.kotlin.lexer.KtTokens;
import org.jetbrains.kotlin.psi.*;
import org.b333vv.metric.model.visitor.kotlin.KotlinMetricUtils;

import static org.b333vv.metric.model.metric.MetricType.NOAM;

/**
 * Kotlin Number Of Added Methods (NOAM) visitor.
 * <p>
 * Calculates the number of operations (methods and accessors) added by a Kotlin class that do not
 * override methods from supertypes. This metric helps assess the new functionality introduced by
 * the class independent of inherited behavior.
 * </p>
 *
 * <h2>Metric Definition</h2>
 * <p>
 * NOAM counts all methods and method-like operations defined in the class that represent new
 * functionality rather than implementations of inherited contracts. This includes both explicit
 * methods and implicit methods generated by Kotlin language features.
 * </p>
 *
 * <h2>What is Counted</h2>
 * <p>
 * The following elements are included in the NOAM count:
 * </p>
 *
 * <h3>1. Explicit Functions</h3>
 * <ul>
 *   <li>All named functions declared in the class body that do not have the {@code override} modifier</li>
 *   <li>Includes functions with special modifiers: {@code inline}, {@code infix}, {@code operator}, {@code suspend}</li>
 *   <li>Includes both public and private functions</li>
 *   <li>Example: {@code fun calculate(): Int} counts as 1 added method</li>
 * </ul>
 *
 * <h3>2. Property Accessors</h3>
 * <ul>
 *   <li><b>Primary constructor properties:</b> Properties declared with {@code val} or {@code var} in the primary constructor</li>
 *   <li><b>Body properties:</b> Properties declared in the class body (excluding companion object properties)</li>
 *   <li><b>Accessor counting:</b>
 *     <ul>
 *       <li>{@code val} property = 1 method (getter)</li>
 *       <li>{@code var} property = 2 methods (getter + setter)</li>
 *     </ul>
 *   </li>
 *   <li><b>Custom accessors:</b> Properties with explicit getter/setter bodies are counted the same way</li>
 *   <li><b>Delegated properties:</b> Properties using {@code by} delegation are counted as standard properties</li>
 *   <li>Properties with {@code override} modifier are excluded</li>
 *   <li>Example: {@code var name: String} counts as 2 added methods (getName, setName)</li>
 * </ul>
 *
 * <h3>3. Data Class Generated Methods</h3>
 * <p>
 * Data classes automatically generate several methods. The following are counted as added methods:
 * </p>
 * <ul>
 *   <li><b>copy() method:</b> Creates a copy of the object with optional parameter modifications (1 method)</li>
 *   <li><b>componentN() methods:</b> Destructuring declarations, one per primary constructor parameter</li>
 * </ul>
 * <p>
 * <b>Note:</b> The following data class methods are <em>not</em> counted because they override methods
 * from {@code Any} (Kotlin's base class):
 * </p>
 * <ul>
 *   <li>{@code equals(Any): Boolean} - overrides {@code Any.equals()}</li>
 *   <li>{@code hashCode(): Int} - overrides {@code Any.hashCode()}</li>
 *   <li>{@code toString(): String} - overrides {@code Any.toString()}</li>
 * </ul>
 *
 * <h3>4. Companion Object Methods</h3>
 * <ul>
 *   <li>All functions declared in companion objects (Kotlin's equivalent of static methods)</li>
 *   <li>These are counted as added methods since they're part of the class's API</li>
 *   <li>Companion object properties and their accessors are <em>not</em> counted in NOAM</li>
 *   <li>Example: {@code companion object { fun create(): MyClass }} counts as 1 added method</li>
 * </ul>
 *
 * <h3>5. Operator Overloading</h3>
 * <ul>
 *   <li>Functions marked with {@code operator} modifier for operator overloading</li>
 *   <li>Examples: {@code operator fun plus()}, {@code operator fun get()}, {@code operator fun invoke()}</li>
 *   <li>These are already counted as part of explicit functions</li>
 * </ul>
 *
 * <h2>What is NOT Counted</h2>
 * <ul>
 *   <li>Functions and properties with {@code override} modifier</li>
 *   <li>Inherited methods from superclasses and interfaces</li>
 *   <li>Extension functions (they're not class members)</li>
 *   <li>Companion object properties (only companion functions are counted)</li>
 *   <li>Init blocks (not methods)</li>
 *   <li>Anonymous/lambda functions inside methods</li>
 *   <li>Data class methods that override {@code Any}: equals, hashCode, toString</li>
 * </ul>
 *
 * <h2>Examples</h2>
 *
 * <pre>{@code
 * // Example 1: Simple class
 * class Calculator {
 *     fun add(a: Int, b: Int): Int = a + b  // 1 added method
 *     fun subtract(a: Int, b: Int): Int = a - b  // 1 added method
 * }
 * // NOAM = 2
 *
 * // Example 2: Class with properties
 * class Person(
 *     val name: String,        // 1 added method (getName)
 *     var age: Int             // 2 added methods (getAge, setAge)
 * ) {
 *     val email: String = ""   // 1 added method (getEmail)
 *     var address: String = "" // 2 added methods (getAddress, setAddress)
 *
 *     fun greet(): String = "Hello"  // 1 added method
 * }
 * // NOAM = 1 + 2 + 1 + 2 + 1 = 7
 *
 * // Example 3: Data class
 * data class Point(val x: Int, val y: Int)
 * // NOAM = 1 (getX) + 1 (getY) + 1 (copy) + 2 (component1, component2) = 5
 * // Note: equals, hashCode, toString are NOT counted (they override Any)
 *
 * // Example 4: Class with companion object
 * class Factory {
 *     fun produce(): String = "product"  // 1 added method
 *
 *     companion object {
 *         fun create(): Factory = Factory()  // 1 added method
 *     }
 * }
 * // NOAM = 2
 *
 * // Example 5: Class with overrides (not counted)
 * open class Base {
 *     open fun execute(): Unit {}
 * }
 * class Derived : Base() {
 *     override fun execute(): Unit {}  // NOT counted (override)
 *     fun process(): Unit {}           // 1 added method
 * }
 * // NOAM = 1
 * }</pre>
 *
 * <h2>Implementation Notes</h2>
 * <ul>
 *   <li>The metric is calculated at class visit time</li>
 *   <li>Abstract classes and interfaces are processed the same way as concrete classes</li>
 *   <li>The {@code override} keyword is the key discriminator for excluding inherited methods</li>
 *   <li>Delegated properties are treated as regular properties for counting purposes</li>
 * </ul>
 *
 * @see org.b333vv.metric.model.visitor.kotlin.type.KotlinNumberOfOverriddenMethodsVisitor
 * @see org.b333vv.metric.model.visitor.kotlin.type.KotlinNumberOfMethodsVisitor
 */
public class KotlinNumberOfAddedMethodsVisitor extends KotlinClassVisitor {

    @Override
    public void visitClass(@NotNull KtClass klass) {
        int added = 0;

        // 1. Count explicit functions (non-override)
        added += countExplicitFunctions(klass);

        // 2. Count property accessors (getters/setters)
        added += countPropertyAccessors(klass);

        // 3. Count companion object methods
        added += countCompanionObjectMethods(klass);

        // 4. Count data class generated methods
        if (klass.isData()) {
            added += countDataClassAddedMethods(klass);
        }

        metric = Metric.of(NOAM, added);
    }

    /**
     * Counts explicit functions declared in the class body that are not overrides.
     * <p>
     * Includes functions with any modifiers (inline, infix, operator, suspend) except override.
     * </p>
     *
     * @param klass the class to analyze
     * @return count of non-override explicit functions
     */
    private int countExplicitFunctions(@NotNull KtClass klass) {
        int count = 0;
        KtClassBody body = klass.getBody();
        if (body != null) {
            for (KtDeclaration decl : body.getDeclarations()) {
                if (decl instanceof KtNamedFunction) {
                    KtNamedFunction func = (KtNamedFunction) decl;
                    if (!func.hasModifier(KtTokens.OVERRIDE_KEYWORD)) {
                        count++;
                    }
                }
            }
        }
        return count;
    }

    /**
     * Counts property accessors (getters and setters) for properties that are not overrides.
     * <p>
     * Counts both primary constructor properties and body properties:
     * <ul>
     *   <li>val property: 1 accessor (getter)</li>
     *   <li>var property: 2 accessors (getter + setter)</li>
     * </ul>
     * Properties in companion objects are excluded as they are not instance members.
     * </p>
     *
     * @param klass the class to analyze
     * @return total count of property accessors
     */
    private int countPropertyAccessors(@NotNull KtClass klass) {
        int count = 0;

        // Count primary constructor properties
        KtPrimaryConstructor primary = klass.getPrimaryConstructor();
        if (primary != null) {
            for (KtParameter param : primary.getValueParameters()) {
                if (param.hasValOrVar()) {
                    // Check for override
                    if (!param.hasModifier(KtTokens.OVERRIDE_KEYWORD)) {
                        // val = 1 (getter), var = 2 (getter + setter)
                        count += param.isMutable() ? 2 : 1;
                    }
                }
            }
        }

        // Count body properties
        KtClassBody body = klass.getBody();
        if (body != null) {
            for (KtDeclaration decl : body.getDeclarations()) {
                if (decl instanceof KtProperty) {
                    KtProperty prop = (KtProperty) decl;

                    // Skip companion object properties - they're not instance members
                    if (KotlinMetricUtils.isInCompanionObject(prop)) {
                        continue;
                    }

                    // Skip override properties
                    if (!prop.hasModifier(KtTokens.OVERRIDE_KEYWORD)) {
                        // val = 1 (getter), var = 2 (getter + setter)
                        count += prop.isVar() ? 2 : 1;
                    }
                }
            }
        }

        return count;
    }

    /**
     * Counts methods declared in companion objects.
     * <p>
     * Companion objects provide class-level (static-like) functionality in Kotlin.
     * Functions in companion objects are considered added methods as they're part
     * of the class's public API.
     * </p>
     * <p>
     * Note: Companion object properties are NOT counted, only functions.
     * </p>
     *
     * @param klass the class to analyze
     * @return count of companion object functions
     */
    private int countCompanionObjectMethods(@NotNull KtClass klass) {
        int count = 0;
        KtClassBody body = klass.getBody();
        if (body != null) {
            for (KtDeclaration decl : body.getDeclarations()) {
                if (decl instanceof KtObjectDeclaration) {
                    KtObjectDeclaration obj = (KtObjectDeclaration) decl;
                    if (obj.isCompanion()) {
                        KtClassBody companionBody = obj.getBody();
                        if (companionBody != null) {
                            for (KtDeclaration companionDecl : companionBody.getDeclarations()) {
                                if (companionDecl instanceof KtNamedFunction) {
                                    KtNamedFunction func = (KtNamedFunction) companionDecl;
                                    // Companion object methods can't have override modifier
                                    // (they're not inherited), so count all of them
                                    count++;
                                }
                            }
                        }
                    }
                }
            }
        }
        return count;
    }

    /**
     * Counts methods added by data class generation that are not overrides.
     * <p>
     * Data classes automatically generate several methods:
     * </p>
     * <ul>
     *   <li><b>copy():</b> counted as 1 added method</li>
     *   <li><b>componentN():</b> one per primary constructor parameter</li>
     *   <li><b>equals(), hashCode(), toString():</b> NOT counted (override Any methods)</li>
     * </ul>
     * <p>
     * This method should only be called for data classes (isData() == true).
     * </p>
     *
     * @param klass the data class to analyze
     * @return count of added data class methods (copy + componentN functions)
     */
    private int countDataClassAddedMethods(@NotNull KtClass klass) {
        int count = 0;

        // copy() method - always added
        count++;

        // componentN() methods - one per primary constructor parameter
        KtPrimaryConstructor primary = klass.getPrimaryConstructor();
        if (primary != null) {
            // Only count val/var parameters (property parameters)
            // Regular parameters without val/var don't generate componentN
            for (KtParameter param : primary.getValueParameters()) {
                if (param.hasValOrVar()) {
                    count++;
                }
            }
        }

        // Note: equals(), hashCode(), toString() are NOT added here
        // because they override methods from Any and thus are not "added" methods

        return count;
    }
}
